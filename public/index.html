<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Opportunités de Paris d'Arbitrage</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f9;
    }
    header {
      background-color: #1e90ff;
      color: white;
      text-align: center;
      padding: 20px;
      font-size: 1.5rem;
    }
    .tabs {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 10px 0;
    }
    .tabs button {
      padding: 10px 20px;
      border: none;
      background-color: #1e90ff;
      color: white;
      cursor: pointer;
      border-radius: 4px;
      font-size: 1rem;
    }
    .tabs button:hover {
      background-color: #0056b3;
    }
    .totals {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 10px 0;
    }
    .totals p {
      margin: 0;
      padding: 10px;
      background-color: #ffffff;
      color: #333;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-weight: bold;
      text-align: center;
      min-width: 150px;
    }
    .container {
      max-width: 1200px;
      margin: 20px auto;
      padding: 10px;
      background-color: white;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    table th, table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
    }
    table th {
      background-color: #1e90ff;
      color: white;
    }
    table tr:hover {
      background-color: #f1f1f1;
    }
    .btn {
      display: inline-block;
      padding: 5px 10px;
      text-decoration: none;
      color: white;
      background-color: #1e90ff;
      border-radius: 4px;
    }
    .btn:hover {
      background-color: #0056b3;
    }
    .arbitrage {
      color: green;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <header>
    Opportunités de Paris d'Arbitrage
  </header>
  <!-- Navigation des onglets -->
  <div class="tabs">
    <button id="tabArbitrage" onclick="showTab('arbitrage')">Opportunités d'Arbitrage</button>
    <button id="tabBookmakers" onclick="showTab('bookmakers')">Bookmakers Rentables</button>
  </div>
  
  <!-- Conteneur pour l'onglet des opportunités d'arbitrage -->
  <div class="container" id="arbitrageTab">
    <div class="totals">
      <p>Total de Bookmakers : <span id="totalBookmakers">0</span></p>
      <p>Total d'Opportunités : <span id="totalOpportunities">0</span></p>
      <p>Total d'Événements : <span id="totalEvents">0</span></p>
    </div>
    <table id="oddsTable">
      <thead>
        <tr>
          <th>Sport</th>
          <th>Événement</th>
          <th>Bookmakers et cotes</th>
          <th>Montants à Parier</th>
          <th>Gain total</th>
        </tr>
      </thead>
      <tbody>
        <!-- Les données seront ajoutées ici dynamiquement -->
      </tbody>
    </table>
  </div>

  <!-- Conteneur pour l'onglet des bookmakers rentables -->
  <div class="container" id="bookmakersTab" style="display: none;">
    <!-- Le contenu sera généré dynamiquement -->
  </div>

  <script>
    async function fetchAllOdds() {
      try {
        // En production, pensez à adapter l'URL du backend si nécessaire
        const response = await fetch('http://localhost:3000/all-odds');
        if (!response.ok) throw new Error(`Erreur HTTP : ${response.status}`);
        const data = await response.json();
        renderOddsTable(data);
      } catch (error) {
        console.error("Erreur lors de la récupération des cotes :", error);
        const tableBody = document.querySelector('#oddsTable tbody');
        tableBody.innerHTML = '<tr><td colspan="5">Impossible de charger les données. Réessayez plus tard.</td></tr>';
      }
    }

    // La fonction calculateArbitrage() calcule les paris d'arbitrage possibles entre les bookmakers d'un événement.
    // La modification apportée consiste à filtrer les paires dont les bookmakers sont identiques.
    function calculateArbitrage(bookmakers) {
      const arbitrageMap = new Map();
      const totalMise = 100;

      bookmakers.forEach((bookmakerA, index) => {
        // On ne considère que les paires où le deuxième bookmaker est différent du premier
        bookmakers.slice(index + 1)
          .filter(bookmakerB => bookmakerB.title !== bookmakerA.title)
          .forEach((bookmakerB) => {
            bookmakerA.markets.forEach(marketA => {
              bookmakerB.markets.forEach(marketB => {
                if (
                  marketA.key === marketB.key &&
                  Array.isArray(marketA.outcomes) &&
                  Array.isArray(marketB.outcomes) &&
                  marketA.outcomes.length >= 2 &&
                  marketB.outcomes.length >= 2
                ) {
                  // --- Combination 1 : utiliser le premier résultat de bookmakerA et le deuxième de bookmakerB ---
                  const outcomeA1 = marketA.outcomes[0];
                  const outcomeB2 = marketB.outcomes[1];
                  let gain1 = 0, stake1_comb1 = 0, stake2_comb1 = 0;
                  if (
                    outcomeA1.price > 0 &&
                    outcomeB2.price > 0 &&
                    (1 / outcomeA1.price + 1 / outcomeB2.price) < 1
                  ) {
                    stake1_comb1 = totalMise / (1 + outcomeB2.price / outcomeA1.price);
                    stake2_comb1 = totalMise - stake1_comb1;
                    gain1 = Math.min(stake1_comb1 * outcomeA1.price, stake2_comb1 * outcomeB2.price) - totalMise;
                  }

                  // --- Combination 2 : utiliser le premier résultat de bookmakerB et le deuxième de bookmakerA ---
                  const outcomeB1 = marketB.outcomes[0];
                  const outcomeA2 = marketA.outcomes[1];
                  let gain2 = 0, stake1_comb2 = 0, stake2_comb2 = 0;
                  if (
                    outcomeB1.price > 0 &&
                    outcomeA2.price > 0 &&
                    (1 / outcomeB1.price + 1 / outcomeA2.price) < 1
                  ) {
                    stake1_comb2 = totalMise / (1 + outcomeA2.price / outcomeB1.price);
                    stake2_comb2 = totalMise - stake1_comb2;
                    gain2 = Math.min(stake1_comb2 * outcomeB1.price, stake2_comb2 * outcomeA2.price) - totalMise;
                  }

                  let bestGain = 0;
                  let bestData = null;

                  if (gain1 > bestGain) {
                    bestGain = gain1;
                    bestData = {
                      bookmaker1: bookmakerA.title,
                      bookmaker2: bookmakerB.title,
                      odds1: outcomeA1.price,
                      odds2: outcomeB2.price,
                      stake1: stake1_comb1,
                      stake2: stake2_comb1,
                      team1: outcomeA1.name,
                      team2: outcomeB2.name,
                      links: [bookmakerA.url, bookmakerB.url]
                    };
                  }
                  if (gain2 > bestGain) {
                    bestGain = gain2;
                    bestData = {
                      bookmaker1: bookmakerB.title,
                      bookmaker2: bookmakerA.title,
                      odds1: outcomeB1.price,
                      odds2: outcomeA2.price,
                      stake1: stake1_comb2,
                      stake2: stake2_comb2,
                      team1: outcomeB1.name,
                      team2: outcomeA2.name,
                      links: [bookmakerB.url, bookmakerA.url]
                    };
                  }

                  if (bestGain > 0 && bestData !== null) {
                    // Création d'une clé unique basée sur le marché et les cotes
                    const betKey = `${marketA.key}-${bestData.odds1}-${bestData.odds2}`;
                    if (!arbitrageMap.has(betKey) || parseFloat(arbitrageMap.get(betKey).gain) < bestGain) {
                      arbitrageMap.set(betKey, {
                        key: betKey,
                        bookmaker1: bestData.bookmaker1,
                        bookmaker2: bestData.bookmaker2,
                        odds1: bestData.odds1,
                        odds2: bestData.odds2,
                        stake1: bestData.stake1,
                        stake2: bestData.stake2,
                        gain: bestGain, // gardé sous forme numérique pour le tri, puis formaté lors de l'affichage
                        team1: bestData.team1,
                        team2: bestData.team2,
                        links: bestData.links
                      });
                    }
                  }
                }
              });
            });
          });
      });

      // Retourner les valeurs uniques du Map
      return Array.from(arbitrageMap.values());
    }

    // Rendu du tableau des opportunités d'arbitrage et mise à jour de l'onglet Bookmakers
    function renderOddsTable(data) {
      const tableBody = document.querySelector('#oddsTable tbody');
      tableBody.innerHTML = '';

      let totalBookmakers = 0;
      let totalOpportunities = 0;
      let totalEvents = 0;

      const allArbitragePairs = [];

      data.forEach(event => {
        const arbitragePairs = calculateArbitrage(event.bookmakers);

        totalEvents += 1;
        totalOpportunities += arbitragePairs.length;
        totalBookmakers += event.bookmakers.length;

        arbitragePairs.forEach(pair => {
          // Enrichir chaque pari avec les informations de l'événement
          allArbitragePairs.push({
            sport: event.sport_key,
            event: `${event.home_team || 'N/A'} vs ${event.away_team || 'N/A'}`,
            ...pair
          });
        });
      });

      // Tri des opportunités par gain décroissant (en convertissant gain en nombre)
      allArbitragePairs.sort((a, b) => parseFloat(b.gain) - parseFloat(a.gain));

      allArbitragePairs.forEach(pair => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${pair.sport || 'N/A'}</td>
          <td>${pair.event}</td>
          <td>
            ${pair.bookmaker1} (${pair.odds1})<br>
            ${pair.bookmaker2} (${pair.odds2})
          </td>
          <td>
            <b>${pair.team1}</b>: ${pair.stake1.toFixed(2)}€ chez ${pair.bookmaker1}<br>
            <b>${pair.team2}</b>: ${pair.stake2.toFixed(2)}€ chez ${pair.bookmaker2}
          </td>
          <td class="arbitrage">Gain : ${parseFloat(pair.gain).toFixed(2)}€</td>
        `;
        tableBody.appendChild(row);
      });

      document.getElementById('totalBookmakers').textContent = totalBookmakers;
      document.getElementById('totalOpportunities').textContent = totalOpportunities;
      document.getElementById('totalEvents').textContent = totalEvents;

      // Mise à jour de l'onglet des bookmakers avec les mêmes données
      renderBookmakersTab(allArbitragePairs);
    }

    // Fonction qui agrège les données pour créer le classement des 10 bookmakers les plus rentables
    // ainsi que la liste de tous les paris (sans doublons) sur ces 10 bookmakers.
    function renderBookmakersTab(allArbitragePairs) {
      // Agrégation par bookmaker
      const bookmakersAggregation = {}; // { bookmakerName: { totalGain, count, bets: {} } }
      allArbitragePairs.forEach(bet => {
        // Pour bookmaker1
        const name1 = bet.bookmaker1;
        if (!bookmakersAggregation[name1]) {
          bookmakersAggregation[name1] = { totalGain: 0, count: 0, bets: {} };
        }
        bookmakersAggregation[name1].totalGain += parseFloat(bet.gain);
        bookmakersAggregation[name1].count += 1;
        bookmakersAggregation[name1].bets[bet.key] = bet;
        // Pour bookmaker2
        const name2 = bet.bookmaker2;
        if (!bookmakersAggregation[name2]) {
          bookmakersAggregation[name2] = { totalGain: 0, count: 0, bets: {} };
        }
        bookmakersAggregation[name2].totalGain += parseFloat(bet.gain);
        bookmakersAggregation[name2].count += 1;
        bookmakersAggregation[name2].bets[bet.key] = bet;
      });

      // Transformation en tableau puis tri décroissant par totalGain
      let sortedBookmakers = Object.entries(bookmakersAggregation)
        .sort((a, b) => b[1].totalGain - a[1].totalGain)
        .slice(0, 10);

      // Création du contenu HTML pour le classement
      let html = '<h2>Top 10 Bookmakers Rentables</h2>';
      html += '<table><thead><tr><th>Rang</th><th>Bookmaker</th><th>Total Gain</th><th>Nombre d\'opportunités</th></tr></thead><tbody>';
      sortedBookmakers.forEach((entry, index) => {
        const name = entry[0];
        const data = entry[1];
        html += `<tr>
                   <td>${index + 1}</td>
                   <td>${name}</td>
                   <td>${data.totalGain.toFixed(2)}€</td>
                   <td>${data.count}</td>
                 </tr>`;
      });
      html += '</tbody></table>';

      // Récupérer tous les paris uniques associés aux top 10 bookmakers
      const uniqueBets = {};
      sortedBookmakers.forEach(entry => {
        const bets = entry[1].bets;
        for (const key in bets) {
          uniqueBets[key] = bets[key];
        }
      });
      let betsArray = Object.values(uniqueBets);
      betsArray.sort((a, b) => parseFloat(b.gain) - parseFloat(a.gain));

      html += '<h2>Liste de tous les paris possibles sur ces Bookmakers</h2>';
      html += '<table><thead><tr><th>Sport</th><th>Événement</th><th>Bookmakers et cotes</th><th>Montants à Parier</th><th>Gain total</th></tr></thead><tbody>';
      betsArray.forEach(bet => {
        html += `<tr>
                   <td>${bet.sport || 'N/A'}</td>
                   <td>${bet.event}</td>
                   <td>
                     ${bet.bookmaker1} (${bet.odds1})<br>
                     ${bet.bookmaker2} (${bet.odds2})
                   </td>
                   <td>
                     <b>${bet.team1}</b>: ${bet.stake1.toFixed(2)}€ chez ${bet.bookmaker1}<br>
                     <b>${bet.team2}</b>: ${bet.stake2.toFixed(2)}€ chez ${bet.bookmaker2}
                   </td>
                   <td class="arbitrage">Gain : ${parseFloat(bet.gain).toFixed(2)}€</td>
                 </tr>`;
      });
      html += '</tbody></table>';

      document.getElementById('bookmakersTab').innerHTML = html;
    }

    // Fonction de gestion des onglets
    function showTab(tabName) {
      const arbitrageTab = document.getElementById('arbitrageTab');
      const bookmakersTab = document.getElementById('bookmakersTab');
      if (tabName === 'arbitrage') {
        arbitrageTab.style.display = 'block';
        bookmakersTab.style.display = 'none';
      } else if (tabName === 'bookmakers') {
        arbitrageTab.style.display = 'none';
        bookmakersTab.style.display = 'block';
      }
    }

    // Actualiser les données toutes les 5 secondes
    setInterval(fetchAllOdds, 5000);

    // Charger une première fois
    fetchAllOdds();
  </script>
</body>
</html>
