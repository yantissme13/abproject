<!DOCTYPE html> 
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Opportunités de Paris d'Arbitrage</title>
  <style>
    /* Styles par défaut (pour PC) */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f9;
    }
    header {
      background-color: #1e90ff;
      color: white;
      text-align: center;
      padding: 20px;
      font-size: 1.5rem;
    }
    .tabs {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 10px 0;
    }
    .tabs button {
      padding: 10px 20px;
      border: none;
      background-color: #1e90ff;
      color: white;
      cursor: pointer;
      border-radius: 4px;
      font-size: 1rem;
    }
    .tabs button:hover {
      background-color: #0056b3;
    }
    .totals {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin: 10px 0;
    }
    .totals p {
      margin: 0;
      padding: 10px;
      background-color: #ffffff;
      color: #333;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      font-weight: bold;
      text-align: center;
      min-width: 150px;
    }
    .container {
      max-width: 1200px;
      margin: 20px auto;
      padding: 10px;
      background-color: white;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      border-radius: 8px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    table th, table td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: center;
    }
    table th {
      background-color: #1e90ff;
      color: white;
    }
    table tr:hover {
      background-color: #f1f1f1;
    }
    .btn {
      display: inline-block;
      padding: 5px 10px;
      text-decoration: none;
      color: white;
      background-color: #1e90ff;
      border-radius: 4px;
    }
    .btn:hover {
      background-color: #0056b3;
    }
    .arbitrage {
      color: green;
      font-weight: bold;
    }
    
    /* Media queries spécifiques pour mobiles (iPhone, Android) */
    @media (max-width: 600px) {
      body {
        padding: 10px;
      }
      header {
        font-size: 1.2rem;
        padding: 15px;
      }
      .tabs {
        flex-direction: column;
        gap: 10px;
        margin: 5px 0;
      }
      .tabs button {
        padding: 8px 15px;
        font-size: 0.9rem;
      }
      .totals {
        flex-direction: column;
        gap: 10px;
        margin: 5px 0;
      }
      .totals p {
        width: 100%;
        min-width: unset;
        padding: 8px;
        font-size: 0.9rem;
      }
      .container {
        margin: 10px;
        padding: 10px;
      }
      table {
        margin: 10px 0;
      }
      table th, table td {
        padding: 5px;
        font-size: 0.8rem;
      }
      .btn {
        padding: 5px 8px;
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <header>
    Opportunités de Paris d'Arbitrage
  </header>
  <!-- Navigation des onglets -->
  <div class="tabs">
    <button id="tabArbitrage" onclick="showTab('arbitrage')">Opportunités d'Arbitrage</button>
    <button id="tabBookmakers" onclick="showTab('bookmakers')">Bookmakers Rentables</button>
  </div>
  
  <!-- Conteneur pour l'onglet des opportunités d'arbitrage -->
  <div class="container" id="arbitrageTab">
    <div class="totals">
      <p>Total de Bookmakers : <span id="totalBookmakers">0</span></p>
      <p>Total d'Opportunités : <span id="totalOpportunities">0</span></p>
      <p>Total d'Événements : <span id="totalEvents">0</span></p>
    </div>
    <table id="oddsTable">
      <thead>
        <tr>
          <th>Sport</th>
          <th>Événement</th>
          <th>Bookmakers et cotes</th>
          <th>Montants à Parier</th>
          <th>Gain total</th>
        </tr>
      </thead>
      <tbody>
        <!-- Les données seront ajoutées ici dynamiquement -->
      </tbody>
    </table>
  </div>

  <!-- Conteneur pour l'onglet des bookmakers rentables -->
  <div class="container" id="bookmakersTab" style="display: none;">
    <!-- Le contenu sera généré dynamiquement -->
  </div>

  <script>
    // Stocker globalement les événements récupérés pour pouvoir rechercher des événements de couverture
    let globalEvents = [];

    async function fetchAllOdds() {
      try {
        const response = await fetch('/all-odds');
        if (!response.ok) throw new Error(`Erreur HTTP : ${response.status}`);
        const data = await response.json();
        globalEvents = data; // sauvegarder pour la recherche de couvertures
        renderOddsTable(data);
      } catch (error) {
        console.error("Erreur lors de la récupération des cotes :", error);
        const tableBody = document.querySelector('#oddsTable tbody');
        tableBody.innerHTML = '<tr><td colspan="5">Impossible de charger les données. Réessayez plus tard.</td></tr>';
      }
    }

    // Fonction pour rechercher de vrais événements (différents) pour un bookmaker donné
    function getHedgeBetsForBookmaker(bookmaker, currentEvent, allEvents) {
      const bets = [];
      allEvents.forEach(event => {
        // Construit le nom de l'événement de l'API (exemple: "Home vs Away")
        const eventName = `${event.home_team || 'N/A'} vs ${event.away_team || 'N/A'}`;
        // Vérifie que l'événement est différent de l'événement du pari d'arbitrage
        if (eventName !== currentEvent) {
          // Vérifie que ce bookmaker figure parmi les bookmakers de cet événement
          const bm = event.bookmakers && event.bookmakers.find(b => b.title === bookmaker);
          if (bm && bm.markets && bm.markets.length > 0) {
            // Utilisons, par exemple, le premier outcome du premier marché pour construire le pari de couverture
            if (bm.markets[0].outcomes && bm.markets[0].outcomes.length > 0) {
              bets.push({
                event: eventName,
                odds: bm.markets[0].outcomes[0].price,
                team: bm.markets[0].outcomes[0].name,
                variation: "Réel"
              });
            }
          }
        }
      });
      // Retourne les deux premiers paris trouvés (s'il y en a)
      return bets.slice(0, 2);
    }

    // La fonction calculateArbitrage calcule les paris d'arbitrage et prépare un objet pour chaque pari sans les couvertures
    function calculateArbitrage(bookmakers) {
      const arbitrageMap = new Map();
      const totalMise = 100;

      bookmakers.forEach((bookmakerA, index) => {
        bookmakers.slice(index + 1)
          .filter(bookmakerB => bookmakerB.title !== bookmakerA.title)
          .forEach((bookmakerB) => {
            bookmakerA.markets.forEach(marketA => {
              bookmakerB.markets.forEach(marketB => {
                if (
                  marketA.key === marketB.key &&
                  Array.isArray(marketA.outcomes) &&
                  Array.isArray(marketB.outcomes) &&
                  marketA.outcomes.length >= 2 &&
                  marketB.outcomes.length >= 2
                ) {
                  const outcomeA1 = marketA.outcomes[0];
                  const outcomeB2 = marketB.outcomes[1];
                  let gain1 = 0, stake1_comb1 = 0, stake2_comb1 = 0;
                  if (
                    outcomeA1.price > 0 &&
                    outcomeB2.price > 0 &&
                    (1 / outcomeA1.price + 1 / outcomeB2.price) < 1
                  ) {
                    stake1_comb1 = totalMise / (1 + outcomeB2.price / outcomeA1.price);
                    stake2_comb1 = totalMise - stake1_comb1;
                    gain1 = Math.min(stake1_comb1 * outcomeA1.price, stake2_comb1 * outcomeB2.price) - totalMise;
                  }

                  const outcomeB1 = marketB.outcomes[0];
                  const outcomeA2 = marketA.outcomes[1];
                  let gain2 = 0, stake1_comb2 = 0, stake2_comb2 = 0;
                  if (
                    outcomeB1.price > 0 &&
                    outcomeA2.price > 0 &&
                    (1 / outcomeB1.price + 1 / outcomeA2.price) < 1
                  ) {
                    stake1_comb2 = totalMise / (1 + outcomeA2.price / outcomeB1.price);
                    stake2_comb2 = totalMise - stake1_comb2;
                    gain2 = Math.min(stake1_comb2 * outcomeB1.price, stake2_comb2 * outcomeA2.price) - totalMise;
                  }

                  let bestGain = 0;
                  let bestData = null;
                  if (gain1 > bestGain) {
                    bestGain = gain1;
                    bestData = {
                      bookmaker1: bookmakerA.title,
                      bookmaker2: bookmakerB.title,
                      odds1: outcomeA1.price,
                      odds2: outcomeB2.price,
                      stake1: stake1_comb1,
                      stake2: stake2_comb1,
                      team1: outcomeA1.name,
                      team2: outcomeB2.name,
                      links: [bookmakerA.url, bookmakerB.url]
                    };
                  }
                  if (gain2 > bestGain) {
                    bestGain = gain2;
                    bestData = {
                      bookmaker1: bookmakerB.title,
                      bookmaker2: bookmakerA.title,
                      odds1: outcomeB1.price,
                      odds2: outcomeA2.price,
                      stake1: stake1_comb2,
                      stake2: stake2_comb2,
                      team1: outcomeB1.name,
                      team2: outcomeA2.name,
                      links: [bookmakerB.url, bookmakerA.url]
                    };
                  }
                  if (bestGain > 0 && bestData !== null) {
                    const betKey = `${marketA.key}-${bestData.odds1}-${bestData.odds2}`;
                    if (!arbitrageMap.has(betKey) || parseFloat(arbitrageMap.get(betKey).gain) < bestGain) {
                      arbitrageMap.set(betKey, {
                        key: betKey,
                        bookmaker1: bestData.bookmaker1,
                        bookmaker2: bestData.bookmaker2,
                        odds1: bestData.odds1,
                        odds2: bestData.odds2,
                        stake1: bestData.stake1,
                        stake2: bestData.stake2,
                        gain: bestGain,
                        team1: bestData.team1,
                        team2: bestData.team2,
                        links: bestData.links
                      });
                    }
                  }
                }
              });
            });
          });
      });
      return Array.from(arbitrageMap.values());
    }

    // Rendu du tableau des opportunités d'arbitrage avec intégration des vraies couvertures
    function renderOddsTable(data) {
      const tableBody = document.querySelector('#oddsTable tbody');
      tableBody.innerHTML = '';

      let totalBookmakers = 0;
      let totalOpportunities = 0;
      let totalEvents = 0;

      const allArbitragePairs = [];

      // Stocke tous les événements (globalEvents est déjà assigné dans fetchAllOdds)
      const allEvents = globalEvents;

      data.forEach(event => {
        const arbitragePairs = calculateArbitrage(event.bookmakers);
        totalEvents += 1;
        totalOpportunities += arbitragePairs.length;
        totalBookmakers += event.bookmakers.length;

        arbitragePairs.forEach(pair => {
          // Ajoute l'événement actuel au pair pour comparaison
          allArbitragePairs.push({
            sport: event.sport_key,
            event: `${event.home_team || 'N/A'} vs ${event.away_team || 'N/A'}`,
            ...pair
          });
        });
      });

      // Pour chaque paire d'arbitrage, ajouter de vrais paris de couverture sur d'autres événements
      allArbitragePairs.forEach(pair => {
        // Pour Bookmaker1
        let hedgeA = getHedgeBetsForBookmaker(pair.bookmaker1, pair.event, allEvents);
        if (hedgeA.length < 2) {
          // Si insuffisant, simuler avec fallback
          hedgeA = [
            { event: "Fallback " + pair.bookmaker1, odds: pair.odds1 * 0.98, team: pair.team1, variation: "-2%" },
            { event: "Fallback " + pair.bookmaker1, odds: pair.odds1 * 1.02, team: pair.team1, variation: "+2%" }
          ];
        }
        // Pour Bookmaker2
        let hedgeB = getHedgeBetsForBookmaker(pair.bookmaker2, pair.event, allEvents);
        if (hedgeB.length < 2) {
          hedgeB = [
            { event: "Fallback " + pair.bookmaker2, odds: pair.odds2 * 0.98, team: pair.team2, variation: "-2%" },
            { event: "Fallback " + pair.bookmaker2, odds: pair.odds2 * 1.02, team: pair.team2, variation: "+2%" }
          ];
        }
        pair.coverageA1 = hedgeA[0];
        pair.coverageA2 = hedgeA[1];
        pair.coverageB1 = hedgeB[0];
        pair.coverageB2 = hedgeB[1];
      });

      // Tri par gain décroissant
      allArbitragePairs.sort((a, b) => parseFloat(b.gain) - parseFloat(a.gain));

      allArbitragePairs.forEach(pair => {
        // Ligne principale pour le pari d'arbitrage
        const row = document.createElement('tr');
        row.className = "main-row";
        row.innerHTML = `
          <td>${pair.sport || 'N/A'}</td>
          <td>${pair.event}</td>
          <td>
            ${pair.bookmaker1} (${pair.odds1})<br>
            ${pair.bookmaker2} (${pair.odds2})
          </td>
          <td>
            <b>${pair.team1}</b>: ${pair.stake1.toFixed(2)}€ chez ${pair.bookmaker1}<br>
            <b>${pair.team2}</b>: ${pair.stake2.toFixed(2)}€ chez ${pair.bookmaker2}
          </td>
          <td class="arbitrage">Gain : ${parseFloat(pair.gain).toFixed(2)}€</td>
        `;
        tableBody.appendChild(row);

        // Ligne de détails pour afficher les 4 paris de couverture réels
        const detailRow = document.createElement('tr');
        detailRow.className = "detail-row";
        // On ne masque plus automatiquement après 3 secondes ; elle reste affichée jusqu'au reclique
        detailRow.style.display = "none";
        detailRow.innerHTML = `
          <td colspan="5" style="font-size: 0.8rem;">
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap;">
              <div style="margin: 5px;">
                <strong>${pair.bookmaker1} - Couverture 1 :</strong><br>
                Événement : ${pair.coverageA1.event}<br>
                Cote : ${pair.coverageA1.odds.toFixed(2)}<br>
                Équipe : ${pair.coverageA1.team}<br>
                Variation : ${pair.coverageA1.variation}
              </div>
              <div style="margin: 5px;">
                <strong>${pair.bookmaker1} - Couverture 2 :</strong><br>
                Événement : ${pair.coverageA2.event}<br>
                Cote : ${pair.coverageA2.odds.toFixed(2)}<br>
                Équipe : ${pair.coverageA2.team}<br>
                Variation : ${pair.coverageA2.variation}
              </div>
              <div style="margin: 5px;">
                <strong>${pair.bookmaker2} - Couverture 1 :</strong><br>
                Événement : ${pair.coverageB1.event}<br>
                Cote : ${pair.coverageB1.odds.toFixed(2)}<br>
                Équipe : ${pair.coverageB1.team}<br>
                Variation : ${pair.coverageB1.variation}
              </div>
              <div style="margin: 5px;">
                <strong>${pair.bookmaker2} - Couverture 2 :</strong><br>
                Événement : ${pair.coverageB2.event}<br>
                Cote : ${pair.coverageB2.odds.toFixed(2)}<br>
                Équipe : ${pair.coverageB2.team}<br>
                Variation : ${pair.coverageB2.variation}
              </div>
            </div>
          </td>
        `;
        tableBody.appendChild(detailRow);

        // Ajout d'un événement de clic pour basculer l'affichage des détails (reste affichée jusqu'à reclique)
        row.addEventListener('click', () => {
          detailRow.style.display = detailRow.style.display === 'none' ? 'table-row' : 'none';
        });
      });

      document.getElementById('totalBookmakers').textContent = totalBookmakers;
      document.getElementById('totalOpportunities').textContent = totalOpportunities;
      document.getElementById('totalEvents').textContent = totalEvents;

      renderBookmakersTab(allArbitragePairs);
    }

    // Fonction pour créer le classement des 10 bookmakers les plus rentables
    function renderBookmakersTab(allArbitragePairs) {
      const bookmakersAggregation = {};
      allArbitragePairs.forEach(bet => {
        const name1 = bet.bookmaker1;
        if (!bookmakersAggregation[name1]) {
          bookmakersAggregation[name1] = { totalGain: 0, count: 0, bets: {} };
        }
        bookmakersAggregation[name1].totalGain += parseFloat(bet.gain);
        bookmakersAggregation[name1].count += 1;
        bookmakersAggregation[name1].bets[bet.key] = bet;
        
        const name2 = bet.bookmaker2;
        if (!bookmakersAggregation[name2]) {
          bookmakersAggregation[name2] = { totalGain: 0, count: 0, bets: {} };
        }
        bookmakersAggregation[name2].totalGain += parseFloat(bet.gain);
        bookmakersAggregation[name2].count += 1;
        bookmakersAggregation[name2].bets[bet.key] = bet;
      });

      let sortedBookmakers = Object.entries(bookmakersAggregation)
        .sort((a, b) => b[1].totalGain - a[1].totalGain)
        .slice(0, 10);

      let html = '<h2>Top 10 Bookmakers Rentables</h2>';
      html += '<table><thead><tr><th>Rang</th><th>Bookmaker</th><th>Total Gain</th><th>Nombre d\'opportunités</th></tr></thead><tbody>';
      sortedBookmakers.forEach((entry, index) => {
        const name = entry[0];
        const data = entry[1];
        html += `<tr>
                   <td>${index + 1}</td>
                   <td>${name}</td>
                   <td>${data.totalGain.toFixed(2)}€</td>
                   <td>${data.count}</td>
                 </tr>`;
      });
      html += '</tbody></table>';

      const uniqueBets = {};
      sortedBookmakers.forEach(entry => {
        const bets = entry[1].bets;
        for (const key in bets) {
          uniqueBets[key] = bets[key];
        }
      });
      let betsArray = Object.values(uniqueBets);
      betsArray.sort((a, b) => parseFloat(b.gain) - parseFloat(a.gain));

      html += '<h2>Liste de tous les paris possibles sur ces Bookmakers</h2>';
      html += '<table><thead><tr><th>Sport</th><th>Événement</th><th>Bookmakers et cotes</th><th>Montants à Parier</th><th>Gain total</th></tr></thead><tbody>';
      betsArray.forEach(bet => {
        html += `<tr>
                   <td>${bet.sport || 'N/A'}</td>
                   <td>${bet.event}</td>
                   <td>
                     ${bet.bookmaker1} (${bet.odds1})<br>
                     ${bet.bookmaker2} (${bet.odds2})
                   </td>
                   <td>
                     <b>${bet.team1}</b>: ${bet.stake1.toFixed(2)}€ chez ${bet.bookmaker1}<br>
                     <b>${bet.team2}</b>: ${bet.stake2.toFixed(2)}€ chez ${bet.bookmaker2}
                   </td>
                   <td class="arbitrage">Gain : ${parseFloat(bet.gain).toFixed(2)}€</td>
                 </tr>`;
      });
      html += '</tbody></table>';

      document.getElementById('bookmakersTab').innerHTML = html;
    }

    // Fonction de gestion des onglets
    function showTab(tabName) {
      const arbitrageTab = document.getElementById('arbitrageTab');
      const bookmakersTab = document.getElementById('bookmakersTab');
      if (tabName === 'arbitrage') {
        arbitrageTab.style.display = 'block';
        bookmakersTab.style.display = 'none';
      } else if (tabName === 'bookmakers') {
        arbitrageTab.style.display = 'none';
        bookmakersTab.style.display = 'block';
      }
    }

    // Fonction pour récupérer de vrais paris de couverture pour un bookmaker différent de l'événement d'arbitrage
    function getHedgeBetsForBookmaker(bookmaker, currentEvent, allEvents) {
      const bets = [];
      allEvents.forEach(event => {
        const eventName = `${event.home_team || 'N/A'} vs ${event.away_team || 'N/A'}`;
        if (eventName !== currentEvent && event.bookmakers) {
          // Vérifier si le bookmaker apparaît dans cet événement
          const bm = event.bookmakers.find(b => b.title === bookmaker);
          if (bm && bm.markets && bm.markets.length > 0 && bm.markets[0].outcomes && bm.markets[0].outcomes.length > 0) {
            bets.push({
              event: eventName,
              odds: bm.markets[0].outcomes[0].price,
              team: bm.markets[0].outcomes[0].name,
              variation: "Réel"
            });
          }
        }
      });
      return bets.slice(0, 2);
    }

    // Actualisation des données toutes les 5 secondes et première charge
    setInterval(fetchAllOdds, 5000);
    fetchAllOdds();
  </script>
</body>
</html>
